#ifndef SQL_AST_H
#define SQL_AST_H

#include "../../data/data-storage.h"
#include "sql-token.h"
#include <stdio.h>
#include <stdlib.h>

typedef enum {
    NT_IDENTIFIER = 1,
    NT_TABLE_IDENTIFIER,
    NT_COLUMN_IDENTIFIER,
    NT_LITERAL,
    NT_BINARY_EXPR,
    NT_SELECT,
    NT_INSERT,
    NT_UPDATE,
    NT_DELETE
} AstNodeType;

typedef enum AstOperatorType {
    OP_ADD = 1, // addition
    OP_SUB,     // subtraction
    OP_MUL,     // multiplication
    OP_DIV,     // division

    OP_AND,     // binary AND
    OP_OR,      // binary OR

    OP_EQU,     // equality
    OP_GRT,     // greater than
    OP_LST      // less than
} AstOperatorType;

typedef struct AstNode AstNode;

struct AstNode {
    AstNodeType type;
    Token *value;

    struct {
        AstNode *table;
        int columns_count;
        AstNode **columns;
        AstNode *where;
    } select;

    struct {
        AstNode *table;
        int columns_count;
        AstNode **columns;
        AstNode **values;
    } insert;

    struct {
        AstNode *left;
        AstNode *right;
        AstOperatorType operation;           
    } binary_expr;
};

static inline AstNode *create_node(Error *out_error) {
    AstNode *node = (AstNode *)malloc(sizeof(AstNode));
    if (!node) {
        fprintf(stderr, "Memory allocation failed\n");
        if (out_error) {
            *out_error = create_error(0, 0, ERR_INTRNL_MEM_ALLOC);
        }
        return NULL;
    }
    return node;
}

// debug

static inline void print_indent(int indent) {
    for (int i = 0; i < indent; i++) printf("  ");
}

// generated by gpt
static inline void print_ast(AstNode* node, int indent) {
    if (!node) return;

    print_indent(indent);
    switch (node->type) {
        case NT_SELECT:
            printf("SELECT\n");
            print_indent(indent + 1); printf("Table:\n");
            print_ast(node->select.table, indent + 2);

            print_indent(indent + 1); printf("Columns:\n");
            for (int i = 0; i < node->select.columns_count; i++)
                print_ast(node->select.columns[i], indent + 2);

            print_indent(indent + 1); printf("Where:\n");
            print_ast(node->select.where, indent + 2);
            break;

        case NT_INSERT:
            printf("INSERT\n");
            print_indent(indent + 1); printf("Table:\n");
            print_ast(node->insert.table, indent + 2);

            print_indent(indent + 1); printf("Columns & Values:\n");
            for (int i = 0; i < node->insert.columns_count; i++) {
                print_indent(indent + 2); printf("Column:\n");
                print_ast(node->insert.columns[i], indent + 3);
                print_indent(indent + 2); printf("Value:\n");
                print_ast(node->insert.values[i], indent + 3);
            }
            break;

        case NT_BINARY_EXPR:
            printf("BINARY_EXPR\n");
            print_indent(indent + 1); printf("Left:\n");
            print_ast(node->binary_expr.left, indent + 2);

            print_indent(indent + 1); printf("Right:\n");
            print_ast(node->binary_expr.right, indent + 2);

            print_indent(indent + 1); printf("Operation: %d\n", node->binary_expr.operation);
            break;

        case NT_IDENTIFIER:
            printf("IDENTIFIER: %s\n", node->value ? node->value->lexeme : "(null)");
            break;

        case NT_TABLE_IDENTIFIER:
            printf("TABLE_IDENTIFIER: %s\n", node->value ? node->value->lexeme : "(null)");
            break;

        case NT_COLUMN_IDENTIFIER:
            printf("COLUMN_IDENTIFIER: %s\n", node->value ? node->value->lexeme : "(null)");
            break;

        case NT_LITERAL:
            printf("LITERAL: %s\n", node->value ? node->value->lexeme : "(null)");
            break;

        case NT_UPDATE:
            printf("UPDATE (not implemented yet)\n");
            break;

        case NT_DELETE:
            printf("DELETE (not implemented yet)\n");
            break;

        default:
            printf("UNKNOWN NODE TYPE: %d\n", node->type);
            break;
    }
}
 

#endif
